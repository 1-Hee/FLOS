## 도구

```
이슈 관리 : JIRA

형상 관리 : Gitlab

커뮤니케이션 : Notion, Mattermost

디자인 : Figma

UCC : ?

CD/CD : Jenkins
```

## 개발 환경

```
VS Code : 1.75.0

IntelliJ : 21.2.4

JVM : 17.0.5

Node.js : 18.12.1

Server : AWS EC2 Ubuntu 20.04

DB : MariaDB, Redis LTS

Docker : 4.15.0
```

## 외부 서비스

```
Google OAuth : application.yml에 해당 내용 있음

Google SMTP : application.yml에 해당 내용 있음

Kakao API : application.yml에 해당 내용 있음

Naver API :application.yml에 해당 내용 있음

Naver Cloud Sentiment : application.yml에 해당 내용 있음

be/src/main/resources/application.yml
```

## 빌드

### 1. DB

- 도커로 DB를 미리 실행합니다. 백엔드보다 먼저 실행되어야합니다.

```
docker run --name docker-maria -d -p 3306:3306 --restart=always -e MYSQL_ROOT_PASSWORD=root -e MARIADB_DATABASE=flosdev -e MARIADB_USER=dev -e MARIADB_PASSWORD=test1234 -e TZ=Asia/Seoul mariadb
docker run --name docker-redis -d -p 6379:6379 --restart=always redis
```

### 2. 프론트엔드 빌드 및 이미지 배포

- nginx conf 설정, fe 폴더 안에 flos.conf로 저장되어 있음.
  
```
server {
  listen 80;
  server_name i8b210.p.ssafy.io;
  server_tokens off;

  location / {
    return 301 https://$host$request_uri;
  }
}

server {
  listen 443 ssl;
  server_name i8b210.p.ssafy.io;
  server_tokens off;

  location /api {
    proxy_pass http://i8b210.p.ssafy.io:8080;
    proxy_set_header   Host $host;
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Host $server_name;
    proxy_cookie_path /api "/; SameSite=None; HTTPOnly; Secure";
  }

  location /swagger {
    proxy_pass http://i8b210.p.ssafy.io:8080/api/swagger-ui/index.html;
    proxy_set_header   Host $host;
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Host $server_name;
  }

  location /jenkins {
    proxy_pass http://i8b210.p.ssafy.io:2080;
    proxy_set_header   Host $host;
    proxy_set_header   X-Real-IP $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Host $server_name;
  }

  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  ssl_certificate /etc/letsencrypt/archive/i8b210.p.ssafy.io/fullchain1.pem;
  ssl_certificate_key /etc/letsencrypt/archive/i8b210.p.ssafy.io/privkey1.pem;
}
```

- root 위치에서 도커 컴포즈로 빌드합니다.

```
docker-compose build nginxapp
```

- 도커 컴포즈로 하단의 도커파일이 실행되어 nginx와 react가 같이 배포됩니다.

```
// 빌드를 위한 노드 버전 이미지를 불러옵니다.
FROM node:18.12.1 AS build

// 빌드를 위한 초기 디렉토리 생성
RUN mkdir -p /home/flos

// 빌드 작업을 할 작업공간 설정
WORKDIR /home/flos

// 소스를 작업공간에 복제
COPY . .

// 미리 build폴더를 만듬
RUN mkdir -p build

// 모듈 강제 설치
RUN npm install react-lottie --force
RUN npm install framer-motion --force

// 빌드 시작
RUN npm run build

// 배포를 위한 nginx 이미지를 불러옵니다.
FROM nginx

// 기존의 nginx 설정을 폴더째로 지웁니다.
RUN rm -rf /etc/nginx/conf.d

// nginx 설정을 넣을 디렉토리를 만듭니다.
RUN mkdir -p /etc/nginx/conf.d

// nginx 설정 conf 파일을 넣습니다.
COPY ./flos.conf /etc/nginx/conf.d/default.conf

// 위에서 빌드한 프로젝트를 그대로 넣습니다.
COPY --from=build /home/flos/build /usr/share/nginx/html

// 포트를 두 개 엽니다. http와 https
EXPOSE 80 443

// nginx를 실행합니다.
CMD ["nginx", "-g", "daemon off;"]
```

### 3. 백엔드 빌드 및 이미지 배포

- root 위치에서 도커 컴포즈로 빌드합니다.

```
docker-compose build springapp
```

- 도커 컴포즈로 하단의 도커파일이 실행되어 백엔드를 빌드합니다.

```
// 빌드를 위한 그래들 환경
FROM gradle:7.4-jdk17-alpine as build

// 작업 디렉토리 설정
WORKDIR /

// 소스를 복제합니다.
COPY . .

// 빌드 시작
RUN gradle clean build --no-daemon

// 배포를 위한 jdk17 이미지를 띄웁니다.
FROM openjdk:17-alpine

// 작업 디렉토리 설정
WORKDIR /

// 위에서 빌드한 프로젝트를 그대로 가져옵니다.
COPY --from=build /build/libs /

// jar를 실행합니다.
CMD ["java", "-jar", "flos-0.0.1-SNAPSHOT.jar"]
```

### 4.  SSL 설정
   
```
// certbot 설치
sudo snap install --classic certbot

// certbot 실행 nginx세팅을 자동으로 잡을것이 아니기때문에 certonly --standalone옵션을 준다
sudo certbot certonly --standalone

// 필요한 도메인, 갱신 만료에 대한 정보를 받을 이메일등을 입력하는 절차를 진행한다.
// 이후 정상적으로 처리되었으면 /etc/letsencrypt/archive/도메인 경로에 nginx설정에 필요한 인증키들이 생성된다.

// 해당 키파일들을 따로 옮기거나 아니면 그 자리에서 쓰거나 상관은 없다.
// 도커파일에서 키파일들이 존재하는 경로에 볼륨설정을 해준 후 nginx 설정파일에서 80번 포트 -> 443 포트 리다이렉트 설정과 443 포트 ssl설정을 해준다. ssl_certificate엔 fullchain.pem 파일을, ssl_certificate_key에는 privkey.pem 파일을 할당해주면 된다.
```

### 5. 이미지 실행

```
docker run --name springBoot -d -p 8080:8080 -v /home/ubuntu/flos:/home/ubuntu/flos --restart=always s08p12b210/springapp:latest

docker run --name nginx -d -p 80:80 -p 443:443 -v /home/ubuntu/flos:/home/ubuntu/flos -v /etc/letsencrypt/archive/i8b210.p.ssafy.io/:/etc/letsencrypt/archive/i8b210.p.ssafy.io/ --restart=always s08p12b210/nginxapp:latest
```

### 6. 백엔드 gradle 의존성

```
plugins {
    id 'java'
    id 'org.springframework.boot' version '2.7.8'
    id 'io.spring.dependency-management' version '1.0.15.RELEASE'
}

group = 'com.onehee'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-mail'
    // swagger
    implementation "io.springfox:springfox-boot-starter:3.0.0"
    implementation "io.springfox:springfox-swagger-ui:3.0.0"
    // jwt
    implementation 'io.jsonwebtoken:jjwt:0.9.1'
    implementation 'javax.xml.bind:jaxb-api'
    compileOnly 'org.projectlombok:lombok'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}

tasks.named('test') {
    useJUnitPlatform()
}
```